:::warning
临近期末，慌得一批，赶紧写点速成笔记救救自己！
:::
## 第一章
### 1.MIPS
MIPS就是百万条指令每秒，还有另外一种含义，即没有内部互锁的流水线级微处理器，这里介绍的MIPS，是一个用来描述计算机性能的尺度。对于给定的程序MIPS的公式就是：

$$
	 MIPS  = \frac{I_n}{T_{cpu}*10^6} = \frac{f_c}{CPI*10^6}
$$
其中：$I_n$就是指令条数，$T_{cpu}$就是指令执行周期数，$f_c$就是时钟速率，是$T_{cpu}$倒数
使用$T_E$代替$T_{cpu}$得到的表达式：

$$
	T_E = \frac{I_n}{MIPS*10^6}
$$
注意到这个$10^6$就是百万的意思了，除以百万。
**计算**
- 有效CPI：指令数乘以CPI然后累加，有效CPI就是公式里面要带入的CPI
- 程序执行时间：$\frac{总指令数*有效CPI}{f_c}$
### 2.阿姆达尔定律
阿姆达尔定律是指：系统中对某一部件或功能采用某种更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。阿姆达尔定律实际上定义了采取增强某部分功能处理后可获得的性能改进或执行时间的加速比。

加速比公式：
$$
	S_p = \frac{T_{old}}{T_{new}} = \frac{1}{(1-F)+(\frac{F}{S})}
$$
$F$就是可以增强部分的占比，$S$就是可以增强的倍率。

### 3.计算机系统结构性能评价标准
直接看题目
![题目一](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E9%A2%98%E7%9B%AE1.png)
计算MIPS就是用指令条数除以（执行时间*$10^6$）
然后取一个为标准，则它的各个程序就是为标准1，然后对应的用$G_i$的MIPS除以标准的MIPS就可以得到对应的值。
最后进行累加开n次方，根据大小来排性能，越大性能越好

![答案一](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E7%AD%94%E6%A1%88%E4%B8%80.png)

## 第二章
:::tip
计算编码和码长
:::
### 1.哈夫曼编码
- 排序
- 每次拿两个最小的合成一个二叉树
- 左1右0

### 2.扩展码
采用2-4编码，那就是初始2位，每次扩展多两位，扩展后出来的数目是4个。
例如下面的：
![编码1](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E7%BC%96%E7%A0%811.png)

一共7个，那么就是先采用2两位编码，然后计算，如果继续采用2位的，则11位扩展的出来的4位则无法满足7，故2位的只用00和01，后面10和11用来扩展，遵循先用完位数短的，再扩展的原则。

![编码2](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E7%BC%96%E7%A0%812.png)

这里的3/3/3指的是每次扩展后的数目是3个，然后每轮扩展末位加两位。
2/7则是扩展2位，然后扩展后数目是7个。

课本解释如下
![编码3](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E7%BC%96%E7%A0%813.png)

平均码长：码长乘以占比后累加求和求均值


## 第三章
### 1.Cache存储时间的计算

系统等效存储周期：
$$
	T_a = H*T_c+(1-H)*T_m 
$$
其中$H$就是Cache命中率，$T_m$就是访问主存所用时间

若使用指令体和数据体存储周期为：
$$
	T_a = f_i(H_i*T_c+(1-H_i)*T_m) + (1-f_i)(H_d*T_c+(1-H_d)*T_m)
$$

其中$f_i$就是访问指令体的占比，同样求数据体也是同理。$H_d$是改进后的Cache的命中率
### 2.映射
**概念**：Cache高速缓冲存储器一种特殊的存储器子系统，其中复制了主存中频繁使用的数据以利于快速访问。为了便于根据CPU送来的地址信息到Cache中去读取数据，必须有某种函数把主存地址映象成Cache地址。实现这种映象的函数叫**映象函数**

有三种映射函数：

- 直接相连
- 全相连
- 组相连

##### 1.直接相连
**原理**：
- 映射函数为 i = j mod m(其中i就是对应的cache块号，j是主存号，m是cache的总块数)
- 将主存分为**若干区，每区容量与Cache总容量相等**。每**区块数与Cache的块数**相同，这样，每区中第i块映射的位置就是Cache的第i块
- 维护一个块表，表的长度为Cache的块数（为了记录Cache中每块存的是主存的第几区），表中每个项目长度是主存区号的长度（为了存下块的编号）。在每次访问主存时查这个块表来对应访问Cache。
主存地址：主存区号  +  区内块号  + 块内地址
Cache地址：区内块号  + 块内地址

**例：设主存容量为1MB，高速缓存Cache容量为16KB，块的大小为512字节。采用直接地址映像法。**

1.  写出主存地址格式。

2.  写出Cache地址格式。

3.  块表的容量是多大。

>Cache块数=16KB/512B=32块  
  则主存每区为32块(解释：将主存分为若干区，每区容量与Cache总容量相等。每区块数与Cache的块数相同，这样，每区中第i块映射的位置就是Cache的第i块)，共1MB/16KB=64区  
  所以**主存地址**为6位区号（共2^6 =64区）+5位区内块号（共 2^5 =32块）+9位块内地址（块容量2^9=512B，按字节编址）  
 所以Cache地址为5位区内块号（共 2^5 =32块），9内块内地址（块容量2^9=512B，按字节编址）,**Cache其实相当于主存的一个区而已**

##### 2.全相连
- 主存中每一块可存入Cache中的的任一位置
- 维护一个目录表，记录Cache每块存的是内存的哪一块。表的长度就为Cache块数（原因上同），每条项目的长度为主存的主存块号的长度，每次访存的时候查表访问。

##### 3.组相连
组相连在全相连和直接相连之间取了折中，拥有了两者的优点，同时弥补了一定的缺点。
- 将Cache分组，将主存分区。**主存区内的块数和Cache的组数相同**(一个Cache相当于主存一个区)
- 主存区内的块和Cache的组采用直接相联映像法，即第主存每区的第i块都映射到Cache的第i组。
- Cache每组组内采用全相联映像法，例如Cache的第3组中有个4块，Cache的第1块存了来自内存第2区的第3块，第2块存了来自内存第6区的第3快，第3、4块空.
- 按照上面的原则，就需要一个表来说明Cache每一组存了哪几区的内存块。访存时查表到对应的区中寻找有没有该内存块。

主存地址：区号   + 区内组号   +  块内地址
Cache地址： 组号  + 组内块号  + 块内地址
>首先计算Cache：按块分组得到组数，再根据按字编还是字节编来计算块内地址。
>对于主存：主存每个区的块数等于Cache的组数，计算得区数，区内块号就是Cache的组数，

直接上个例题

**例：一个组相联映像Cache由64个存储块组成， 每组包含4个存储块。主存包含4096个存储块，每块由128字组成。访存地址为字地址。**

1.写出主存地址位数和地址格式  

2.写出Cache地址位数和地址格式；  

>Cache组数为64/4=16组  
   主存每区内的块数=Cache的组数，则主存的区数为4096/16=256区，每区内有16个存储块  
  那么**主存地址**的组成为8位区号（256区）+4位区内块号（16个存储块）+7位块内地址（一块128字，按字编址）**Cache地址**为4位组号（16组）+2位组内块号（每组4快）+7位块内地址（一共128字，按字编址）

**复习课例题**：
设某计算机的Cache-主存存储层次采用组相联映像，已知主存容量为8MB，Cache容量为8KB，按4字块分组，每个字块的长度为8个字（32位/字）。

(1)设计主存地址格式和Cache地址格式，标出各字段的位数。

(2)假设Cache起始内容为空，CPU从主存单元0，1，2，……，2063依次读出2064个字，并重复此读数序列共10次。若Cache速度为主存速度的10倍，且采用LRU算法，问利用Cache后速度提高了多少倍？
> ∵Cache的容量为8KB，即8KB/4B=$2^{11}$字
> 
> ∴Cache地址共需11位
> 
> ∵字块大小为8个字
> 
> ∴块内地址为3位
> 
> ∵每组为4个字块
> 
> ∴块号占2位，剩下的11-3-2=6位为组号所占的位数。
> 
> 由以上分析可知，Cache地址格式如下：

![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/Cache%E5%9C%B0%E5%9D%80.png)


>∵主存的容量为8MB，即8MB/4B=$2^{21}$字
>
>∴主存地址共需21位
>
>∵主存地址格式中的组号、块号、块内地址的位数与Cache的相同
>
>∴区号的位数为21-6-2-3=10位
>
>由以上分析可知，主存地址格式为：

![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80.png)

按照要求，主存有258块，但是Cache只有256块，所以装入的时候会有替换，一开始0~255块可以装入。但是256和257就要进行替换，采用LRU，因为前256刚刚装满，所以会从第0块Cache开始装入替换，也就是如下图的0、1、2、3、256、257这六块进行替换。
![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E6%9B%BF%E6%8D%A2.png)

### 3.Cache透明性分析
两种方法：
- 写回法
- 写直达法
#### 1.写回法
写回法----是指在CPU执行写操作时，信息只写入Cache，仅当需要被替换时，才将已被写入过的Cache块先送回主存，然后再调入新块。
写回法包括简单写回法和采用标志位写回法。

简单写回法----指不管块是否更新，都进行写回操作。

采用标志位写回法---只在块被更新过时，才进行写回操作。

#### 2.写直达法
利用Cache-主存存储层次在处理机和主存之间的直接通路，每当处理机写入Cache的同时，也通过此通路直接写入主存。

#### 3.两种情况
- 写Cache命中
>可直接对Cache块进行写操作，根据所用更新主存内容的算法，决定何时对主存相应块的内容进行更新。

- 不命中
>无论是写回法还是写直达法都有一个在写时是否取的问题。一般有两种方法（又称写算法或写策略）：
>
>**1.不按写分配法**----当Cache写不命中时只写入主存，该写地址单元所在块不从主存调入Cache。**通俗来说就是，写不命中，怎么写都不命中，只有读一次后再写就命中了**
>
>**2.按分配写法**----当Cache写不命中时除写入主存，还将该写地址单元所在块从主存调入Cache。**读写不命中就会写入，然后下次就命中了**

写回法一般采用按写分配法，写直达法一般采用不按写分配法。

### 4.Cache的取算法
### 预取算法
- 恒预取----是指只要访问到主存第i块的某个字，不论Cache是否命中，恒发预取命令。
- 不命中时预取----是指只当访问第i块的某个字不命中时，才发预取命令。
恒预取公式：
$$
	H^{'} = \frac {H+n-1}{n}
$$
H是原命中率，n是Cache块大小和数据块重复使用的次数乘积

**例**：如果Cache的块大小为4个字，预取到Cache中的数据的重复利用率为5次，Cache存储系统原来的命中率为H=0.8，则采用预取算法后，命中率为多少？若Tm=5Tc，则Cache-主存存储系统的访问效率e为多少？

采用预取技术后，命中率为：

$$
		 H^{'} = \frac {0.8 + 4*5 -1}{4*5} = 0.99
$$

Cache - 主存存储系统的访问效率e为：
$$
	e = \frac{T_c}{T_a} = \frac{T_c}{H^{'}T_c + (1-H^{'})T_m} = 0.96
$$
## 第四章
:::tip
吞吐率、效率、加速比
:::
### 1.普通流水线
如下：
![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E6%99%AE%E9%80%9A%E6%B5%81%E6%B0%B4%E7%BA%BF1.png)
**假设连续输入n条指令，求对应的实际吞吐率、效率**

吞吐率：
$$
		T_{pipeline} = \sum_1^i\Delta t_i + (n-1) \Delta t_{max}
$$
$$
		TP = \frac{n}{T_{pipeline}}
$$
其中n就是执行的指令数目，$t$就是各个段的时间，执行指令的数目，除以T得到吞吐率，也可以转化为MIPS。

效率：

$$
	E = TP* \frac{\sum_1^i \Delta t_i}{m}
$$
m就是段的个数。

**突破瓶颈**
- 找到最小的 $\Delta t$ ，不等于$\Delta t$就进行修改
- 一般采用并联的方式
- 重新计算上述各值

### 2.设计计算功能的流水线
直接看题目：
![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E8%AE%A1%E7%AE%97%E5%99%A8%E6%B5%81%E6%B0%B4%E7%BA%BF1.png)

对于设计画出流水线的题目：

**吞吐率**：

$$
	TP = \frac{n}{m*\Delta t}
$$
n是有几个结果，m是流水线完成的时间

**加速比**

$$
		S = \frac{n*T}{m*\Delta t}
	
$$
n是结果数目，T是各自运算不采用流水线设计要花费的时间，也就是时间求和。

**效率**

$$
		E = \frac{S_1}{S_2}
$$
S1是流水线面积，S2是大矩形面积(取最大的宽和长)
![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E8%AE%A1%E7%AE%97%E5%99%A8%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%AD%94%E6%A1%88.png)

### 3.带冲突的流水线
首先会获得一个一个预约表，按照如下步骤进行解答：

- 根据预约表得出禁止表(同一功能段可能发生冲突的时间间隔)
- 根据禁止表得冲突向量，禁止表对应位置上置1，无则为0，表示不冲突。例如F={1,3,4,8}则设计就是10001101
- 求解后继状态
- 冲突向量上为0的就是可以进行操作的后继状态，例如上述10001101，有2、5、6、7四个状态。
- 右移，然后跟原始冲突向量相或，即可得到下一个冲突向量
- 寻找形成的回环，计算调度策略和平均延迟时间

**最大吞吐率**

$$
	TP = \frac{1}{m \Delta t}
$$
分母就是对应的最优调度策略(找最小的)

**实际吞吐率**

$$
	TP = \frac{n}{sum*\Delta t}
$$
n为任务数目，sum为对应的时间，其中sum的计算使用的是最优调度策略(因为形成了循环)，**这里注意，最后一个任务不可采用最优调度，因为不构成循环，所以采用的是原始时间。**

![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E5%86%B2%E7%AA%81%E6%B5%81%E6%B0%B4%E7%BA%BF.png)

![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E5%86%B2%E7%AA%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%AD%94%E6%A1%881.png)

![](https://rachelnotebook.oss-cn-shenzhen.aliyuncs.com/docs/Foundation/imgs/others/%E5%86%B2%E7%AA%81%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%AD%94%E6%A1%882.png)
