## 简单图、多重图、子图
**满足如下条件的就是简单图：**

1. 不存在重复边
2. 不存在顶点到自己的表(自环)

**多重图：**

1. 若图中某两个顶点的边数大于1
2. 允许顶点通过一条边和自身关联

数据结构里面只讨论简单图
**子图：**

1. $G = (V,E)和G^{'}=(V^{'},E^{'})$
2. 其中$V^{'}是V的子集E^{'}是E的子集$
3. **如果顶点集相同，则是生成子图**

## 简单路径、简单回路

1. 一个路径序列中不存在重复节点的是简单路径
2. 除第一个顶点和最后一个顶点外，其余节点不重复出现的是简单回路
## 无向图
**这些术语跟有向图区分开来**

| **连通** | **连通图** | **连通分量** | **完全图** | **度** |
| --- | --- | --- | --- | --- |
| 两个顶点可达 | 图任意两点连通 | 极大连通子图就是连通分量，要求包含所有边 | 边数为：n(n-1)/2 | 度数之和等于边的两倍：Sumn = 2e |

## 有向图
| **强连通图** | **强连通分量** | **完全图** | **度** |
| --- | --- | --- | --- |
| v到w和w到v都有路径 | 极大强连通子图就是强连通分量 | 边数为：n(n-1) | 出度=入度=e |

## 两种存储结构：矩阵和链表
### 邻接矩阵
邻接矩阵是采用二维数组的存储方式来存储图，为v行v列的矩阵，其中若$v_i到v_j有路径，则A[i][j]为1，或者是对应的路径权值$。
$$\begin{aligned}
	&当(v_i,v_j)是G的边，则a[i][j] = 1 \\
	&否则a[i][j] = 0或无穷 \\
\end{aligned}$$
值可以是权值，有向图和无向图有着一定的区别（无向图对称，可以压缩的），能理解其表达的意思就OK。
随便写个矩阵：
$$\begin{bmatrix}
0 & 1 & 1& 0  \\
0 & 0 & 0 &0 \\
0 & 0 & 0 &1 \\
1 & 0 & 0 &0 \\
\end{bmatrix}$$
其中当图是无向图的时候，矩阵是对称的。有向图则不一定，有向图中，**行代表顶点的出，列代表顶点的入**，比如上述矩阵，顶点$v_1$有指向$v_2和v_3$的两条边，而又有$v_4指向v_1$的一条边。
```cpp
typedef struct{
	char vex[N];	
    int weight[N][N];	//N*N邻接矩阵，每条边的权值用int变量表示
	int vexnum,arcnum; 	//图的当前顶点数和弧数
}MGraph;

```
**空间复杂度**：显而易见空间复杂度跟顶点个数有关，为$O(n^2)$
对于$A^n$的元素$A^n[i][j]$表示的是由顶点i到j长度为n的路径有多少条。**该结论了解即可**
邻接矩阵适用于存储相对稠密的图。
### 邻接表
看下图理解：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/27603626/1695215094553-31aa834b-1c96-48e9-b35c-626a43ac2ba5.png#averageHue=%23f6f6f5&clientId=u3d456c7d-4c1b-4&from=paste&height=206&id=u61400e9e&originHeight=258&originWidth=797&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=66898&status=done&style=none&taskId=u4aca03ab-2b07-441d-b3c5-232251018ad&title=&width=637.6)
设计顶点表结点和边表结点来存储。顶点表节点由顶点域和指向第一条邻接边的指针构成，包含(顶点域data，边表头指针first)。边表结点中包含指向下一跳邻接边的指针。
```cpp
typedef struct ArcNode{			//边表
	int vexIndex;				
    int weight;                
	struct ArcNode *next;		//指向下一个边表结点
}ArcNode; 

typedef struct VNode{	//顶点表
	char data; 			
	ArcNode *first; 	//指向第一条依附该顶点的弧的指针
}VNode;

typedef struct{
	VNode vex[N];    		
	int vexnum,arcnum; 		//图的顶点数和边数
} ALGraph; 					//ALGraph是以邻接表存储的图类型

```
**空间复杂度**：空间复杂度跟顶点个数和边数有关，若为有向图则$O(|V|+|E|)$若为无向图则$O(|V|+2|E|)$。

## BFS和DFS
### BFS
**1）树的广搜**
广度优先搜索遍历是在各种算法中广泛应用的一种优先遍历算法。就是往宽了去搜索，再搜索下一层。

1. 若树非空，根节点入队
2. 若队列非空，队头元素出队并且访问，同时将其孩子入队
3. 重复2直到队列为空为止

树的BFS借助了队列的帮助，与此同时因为树中不存在回路，搜索到相邻节点的时候不可能搜索到已经访问到的节点。
**2）图的广搜**
在图中，广度优先搜索会面临一个问题就是图若存在回路，会重复访问到已经访问过的结点，从而带来不必要的时间开销，此处需要设计一个辅助数组来标记是否被访问过，其余的思想与树的层次遍历思想大致相同，从一个节点开始，访问其邻接点，依次进行。具体思想如下：

1. 从起始节点开始找到与顶点相邻的所有顶点(过程会有入队和出队操作)
2. 辅助数组标记
3. 循环递归
4. 需要借助辅助队列
```cpp
bool visited[MAX_SIZE];
void BFSTraverse(Graph G){
	for(i = 0;i<G.vexnuml;i++)
		visited[i] = fasle;
	InitQueue(Q);
	for(i = 0;i<G.vexnum;i++){
		if(!visited[i])
			BFS(G,i);
	}
}

void BFS(Graph G){
	visit(v);
	visited[v] =true;
	EnQueue(Q,v);
	while(!isEmpty(Q)){
		DeQueue(Q,v);
		for(w = FirstNeighbor(G,v);w>=0;w = NextNeighbor(G,v)){
			if(!visited[w]){
				visit(w);
				visited[w] = true;
				EnQueue(Q,v);
			}
		}
	}
}
```
**时间复杂度分析**：时间复杂度取决于具体数据结构的搜索方式，也就是跟存储方式有关：邻接表和邻接矩阵。若采用邻接表，每个顶点都搜索一次，需要$O(|V|)$次，搜索邻接边需要$O(|E|)$，故为$O(|V|+|E)$。当采用邻接矩阵的时候，每个顶点都需要访问一次，算上边的访问，一共需要$O(|V|^2)$。

**空间复杂度分析**：空间开销来源于辅助队列，故空间开销为$O(|V|)$。
### DFS
图的DFS就类似于树的先序遍历，理解就是往深了走，顺着一个节点往下一直搜索，直到没有就回溯，持续回溯，直到回溯到一个又可以重新向下搜索的节点。跟BFS一样同样需要一个标记数组来标记节点是否被访问过。如下是伪代码：
```cpp
bool visited[MAX_SIZE];
void DESTralverse(Graph G){
	for(v = 0;v<G.vexnum;++v)
		visited[v] = false;
	for(v = 0;v<G.vexnum;++v)
		if(!visited[w])
			DFS(G,v);
}

void DFS(Graph G,int v){
	visit(v);
	visited[v] = true;
	for(w = FirstNeighbor(G,v);w>=0;w = NextNeighbor(G,v))
		if(!visited[w])
			DFS(G,v);
}
```
**时间复杂度分析**：时间复杂度取决于具体数据结构的搜索方式，也就是跟存储方式有关：邻接表和邻接矩阵。若采用邻接表，每个顶点都搜索一次，需要$O(|V|)$次，搜索邻接边需要$O(|E|)$，故为$O(|V|+|E)$。当采用邻接矩阵的时候，每个顶点都需要访问一次，算上边的访问，一共需要$O(|V|^2)$。

**空间复杂度分析**：DFS算法是递归算法，需要借助一个递归空间栈，在最优情况下，空间复杂度可以为$O(1)$，平均的为$O(|V|)$。
## 生成树
包含所有顶点的极小连通子图子图，其中结点数为n，边数为n-1，少一条边非连通，多一条边有回路。其具有性质：

1. 不一定唯一
2. 不唯一但是权值之和唯一(存在权值相同的边时会存在不唯一)
3. $|E| = |V| -1$

**最小生成树的两种算法：“普利姆(Prim)和克鲁斯卡尔(Kruskal)”**
### 普利姆(Prim)
这个算法是**选点**的算法，一开始选择一个顶点加入集合$S$，此时树中只有一个顶点，然后从剩余顶点集合$T$中选取相距树中顶点集合最近的点，并且将该边加入集合$S$中，过程要记得避开回路，也是离散数学中的避圈法。每次都会加入一个点和一条边，$n-1$次后得到最小生成树。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/27603626/1695214646211-841d95d2-2e26-43ce-a2b7-166d9fd420bd.png#averageHue=%23fbfafa&clientId=u3d456c7d-4c1b-4&from=paste&height=641&id=u9cd812ea&originHeight=801&originWidth=591&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=163271&status=done&style=none&taskId=uc3ea4b40-07b3-45f7-8457-0b4adac5f7c&title=&width=472.8)
### **克鲁斯卡尔(Kruskal)**
Prim是选点，而Kruskal就是**选边**的算法，直接给边按权排序，按从小到大选取，过程需要避开回路，也是避圈法的一种，该算法的思想本质是贪心，有条件的贪心。一直添加$n-1$次即可。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/27603626/1695214668850-edb86fb5-6d49-4dc8-a7e9-32a34519ec27.png#averageHue=%23fbfbfb&clientId=u3d456c7d-4c1b-4&from=paste&height=653&id=ub6974d65&originHeight=816&originWidth=599&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=165081&status=done&style=none&taskId=u09669734-3098-457e-ab16-1bdc376a790&title=&width=479.2)
## 最短路径问题(迪杰斯特拉算法)
## 拓扑
## 关键路径
